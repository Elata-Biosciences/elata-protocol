#!/usr/bin/env node

/**
 * Generate Frontend Configuration from Deployment
 * 
 * Reads deployments/local.json and generates:
 * 1. frontend/.env.local - Environment variables
 * 2. frontend/src/config/contracts.ts - TypeScript config
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface DeploymentConfig {
  network: string;
  chainId: number;
  deployer: string;
  contracts: {
    ELTA: string;
    ElataXP: string;
    VeELTA: string;
    LotPool: string;
    RewardsDistributor: string;
    ElataTimelock: string;
    ElataGovernor: string;
    AppFactory: string;
    AppModuleFactory: string;
    TournamentFactory: string;
    UniswapV2Factory: string;
    UniswapV2Router: string;
  };
  testAccounts: string[];
}

function main() {
  console.log('üîß Generating frontend configuration...\n');

  const projectRoot = join(__dirname, '..');
  const deploymentPath = join(projectRoot, 'deployments', 'local.json');
  const frontendDir = join(projectRoot, 'frontend');
  
  // Check if deployment exists
  if (!existsSync(deploymentPath)) {
    console.error('‚ùå Error: deployments/local.json not found!');
    console.error('   Run deployment first: npm run dev:deploy');
    process.exit(1);
  }

  // Read deployment config
  const deployment: DeploymentConfig = JSON.parse(readFileSync(deploymentPath, 'utf-8'));

  // Generate .env.local
  generateEnvLocal(deployment, frontendDir);

  // Generate TypeScript config
  generateTsConfig(deployment, frontendDir);

  console.log('\n‚úÖ Frontend configuration generated successfully!');
  console.log('\nFiles created:');
  console.log('  - frontend/.env.local');
  console.log('  - frontend/src/config/contracts.ts');
}

function generateEnvLocal(deployment: DeploymentConfig, frontendDir: string) {
  const env = `# Auto-generated by generate-config.ts
# Local Development Environment

# Network Configuration
NEXT_PUBLIC_CHAIN_ID=${deployment.chainId}
NEXT_PUBLIC_RPC_URL=http://127.0.0.1:8545

# Contract Addresses - Core Protocol
NEXT_PUBLIC_ELTA_ADDRESS=${deployment.contracts.ELTA}
NEXT_PUBLIC_ELATA_XP_ADDRESS=${deployment.contracts.ElataXP}
NEXT_PUBLIC_VE_ELTA_ADDRESS=${deployment.contracts.VeELTA}
NEXT_PUBLIC_LOT_POOL_ADDRESS=${deployment.contracts.LotPool}
NEXT_PUBLIC_REWARDS_DISTRIBUTOR_ADDRESS=${deployment.contracts.RewardsDistributor}
NEXT_PUBLIC_ELATA_TIMELOCK_ADDRESS=${deployment.contracts.ElataTimelock}
NEXT_PUBLIC_ELATA_GOVERNOR_ADDRESS=${deployment.contracts.ElataGovernor}

# Contract Addresses - App Ecosystem
NEXT_PUBLIC_APP_FACTORY_ADDRESS=${deployment.contracts.AppFactory}
NEXT_PUBLIC_APP_MODULE_FACTORY_ADDRESS=${deployment.contracts.AppModuleFactory}
NEXT_PUBLIC_TOURNAMENT_FACTORY_ADDRESS=${deployment.contracts.TournamentFactory}

# DEX Addresses (Mock Uniswap)
NEXT_PUBLIC_UNISWAP_V2_FACTORY_ADDRESS=${deployment.contracts.UniswapV2Factory}
NEXT_PUBLIC_UNISWAP_V2_ROUTER_ADDRESS=${deployment.contracts.UniswapV2Router}

# Test Accounts
NEXT_PUBLIC_TEST_ACCOUNT_1=${deployment.testAccounts[0] || ''}
NEXT_PUBLIC_TEST_ACCOUNT_2=${deployment.testAccounts[1] || ''}
NEXT_PUBLIC_TEST_ACCOUNT_3=${deployment.testAccounts[2] || ''}
NEXT_PUBLIC_TEST_ACCOUNT_4=${deployment.testAccounts[3] || ''}
NEXT_PUBLIC_TEST_ACCOUNT_5=${deployment.testAccounts[4] || ''}

# Development Mode
NEXT_PUBLIC_DEV_MODE=true
`;

  const envPath = join(frontendDir, '.env.local');
  writeFileSync(envPath, env);
  console.log('‚úì Generated .env.local');
}

function generateTsConfig(deployment: DeploymentConfig, frontendDir: string) {
  const ts = `/**
 * Auto-generated Contract Configuration
 * 
 * Generated by: scripts/generate-config.ts
 * Source: deployments/local.json
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 */

export const CHAIN_ID = ${deployment.chainId};
export const RPC_URL = 'http://127.0.0.1:8545';

export const contracts = {
  // Core Protocol
  ELTA: '${deployment.contracts.ELTA}' as const,
  ElataXP: '${deployment.contracts.ElataXP}' as const,
  VeELTA: '${deployment.contracts.VeELTA}' as const,
  LotPool: '${deployment.contracts.LotPool}' as const,
  RewardsDistributor: '${deployment.contracts.RewardsDistributor}' as const,
  ElataTimelock: '${deployment.contracts.ElataTimelock}' as const,
  ElataGovernor: '${deployment.contracts.ElataGovernor}' as const,
  
  // App Ecosystem
  AppFactory: '${deployment.contracts.AppFactory}' as const,
  AppModuleFactory: '${deployment.contracts.AppModuleFactory}' as const,
  TournamentFactory: '${deployment.contracts.TournamentFactory}' as const,
  
  // Mock DEX
  UniswapV2Factory: '${deployment.contracts.UniswapV2Factory}' as const,
  UniswapV2Router: '${deployment.contracts.UniswapV2Router}' as const,
} as const;

export const testAccounts = ${JSON.stringify(deployment.testAccounts, null, 2)} as const;

export type ContractName = keyof typeof contracts;
export type ContractAddress = typeof contracts[ContractName];

// Helper to get contract address by name
export function getContractAddress(name: ContractName): string {
  return contracts[name];
}

// Export deployment info
export const deploymentInfo = {
  network: '${deployment.network}',
  chainId: ${deployment.chainId},
  deployer: '${deployment.deployer}',
  timestamp: new Date().toISOString(),
} as const;
`;

  const configDir = join(frontendDir, 'src', 'config');
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
  
  const tsPath = join(configDir, 'contracts.ts');
  writeFileSync(tsPath, ts);
  console.log('‚úì Generated src/config/contracts.ts');
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { main as generateConfig };

